/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef RAYMARCH_H_
# define RAYMARCH_H_

const char *raymarch_glsl =
 "uniform vec3 V,C,A,D;"
 "float v=V.z;"
 "const vec3 m=vec3(0.,.001,1.);"
 "const float f=3.14159;"
 "float x(float v)"
 "{"
   "return fract(sin(v)*43758.5);"
 "}"
 "float s(vec2 v)"
 "{"
   "return fract(sin(17.*x(v.x)+54.*x(v.y)));"
 "}"
 "float n(vec2 v)"
 "{"
   "vec2 a=floor(v);"
   "v-=a;"
   "return mix(mix(s(a),s(a+m.zx),v.x),mix(s(a+m.xz),s(a+m.zz),v.x),v.y);"
 "}"
 "float t(float v)"
 "{"
   "float a=floor(v);"
   "v-=a;"
   "return mix(x(a),x(a+1.),v);"
 "}"
 "vec3 p(float v)"
 "{"
   "return vec3(t(v),t(v+13.),t(v+29.));"
 "}"
 "float n(vec3 v,vec3 x)"
 "{"
   "return v=abs(v)-x,max(v.x,max(v.y,v.z));"
 "}"
 "mat3 r(float v)"
 "{"
   "float f=sin(v),a=cos(v);"
   "return mat3(a,0.,f,0.,1.,0,-f,0.,a);"
 "}"
 "float p(vec3 v,float x)"
 "{"
   "return length(v)-x;"
 "}"
 "vec3 r(vec3 v,vec3 f)"
 "{"
   "return mod(v,f)-f*.5;"
 "}"
 "float n(vec3 v,float f,float x,float z)"
 "{"
   "float a=length(v);"
   "return max(abs(v.y)-z,max(a-x,f-a));"
 "}"
 "float e(vec2 v)"
 "{"
   "return max(v.x,v.y);"
 "}"
 "float i(vec3 f)"
 "{"
   "const float a=2.8;"
   "const int x=5;"
   "vec3 m=vec3(1.1,.9,1.9);"
   "for(int z=0;z<x;++z)"
     "{"
       "f=f*r(.1+v*.3);"
       "f=abs(f);"
       "f.xy+=step(f.x,f.y)*(f.yx-f.xy);"
       "f.xz+=step(f.x,f.z)*(f.zx-f.xz);"
       "f.yz+=step(f.y,f.z)*(f.zy-f.yz);"
       "f=f*r(.7);"
       "f.xy=f.xy*a-(a-1.)*m.xy;"
       "f.z=a*f.z;"
       "if(f.z>.5*m.z*(a-1.))"
         "f.z-=m.z*(a-1.);"
     "}"
   "return n(f,vec3(1.))*pow(a,-float(x));"
 "}"
 "int a=0;"
 "void e(inout float v,float f,int m)"
 "{"
   "if(f<v)"
     "v=f,a=m;"
 "}"
 "float d(vec3 v)"
 "{"
   "float f=e(abs(v.xy)-vec2(2.,.1));"
   "f=f+max(0.,.2*n(r(v,vec3(.15)),vec3(.01)));"
   "v.x=abs(v.x)+.02;"
   "float a=e(abs(v.xy-vec2(2.,1.))-vec2(.02)),x=max(abs(mod(v.z,.4)-.2)-.02,max(abs(v.y-.5)-.5,abs(v.x-2.)-.02));"
   "return min(f,min(a,x));"
 "}"
 "float o(vec3 v)"
 "{"
   "return n(v-vec3(33.,1.6,0.),vec3(20.,1.5,1.96));"
 "}\n"
 "#define LN 5\n"
 "vec3 c[LN],l[LN];"
 "float h(vec3 v)"
 "{"
   "float f=100000.;"
   "for(int a=0;a<LN;++a)"
     "e(f,length(v-c[a])-.1,a+100);"
   "float a=length(v.xz),m=atan(v.x,v.z),x=length(v),z=-min(o(vec3(abs(v.x),v.yz)),o(vec3(abs(v.z),v.yx))),s=max(-p(v,19.),n(r(v,vec3(2.)),vec3(.8))),y=-p(v,20.);"
   "e(f,y,1);"
   "e(f,s,2);"
   "f=max(z,f);"
   "float l=p(v,9.);"
   "l=max(l,abs(abs(v.y)-3.)-.5);"
   "l=min(l,n(r(v,vec3(11.8)),vec3(.1,100.,.1)));"
   "l=max(l,-p(v,8.9));"
   "float t=d(vec3(a-13.,v.y,m*10.));"
   "t=min(t,max(15.-a,min(d(v.zyx),d(v))));"
   "t=max(t,z);"
   "e(f,l,3);"
   "e(f,t,4);"
   "if(x<8.)"
     "e(f,i(v/D.x)*D.x,5);"
   "else"
     " f=min(f,x+2.);"
   "return f;"
 "}"
 "vec3 w(vec3 v)"
 "{"
   "float f=h(v);"
   "return normalize(vec3(h(v+m.yxx)-f,h(v+m.xyx)-f,h(v+m.xxy)-f));"
 "}"
 "void d(vec3 v,out vec3 f,out vec3 m,out vec3 x,out float i,out float z)"
 "{"
   "f=w(v);"
   "x=m=vec3(0.);"
   "i=z=0.;"
   "if(a==1)"
     "x=vec3(.5),i=.4,z=.99;"
   "else"
     " if(a==2)"
       "{"
         "float t=n(r(v,vec3(2.)),vec3(.6));"
         "x=vec3(.56,.57,.58);"
         "i=mix(.15,.5,step(t,0.));"
         "z=.8;"
       "}"
     "else"
       " if(a==3)"
         "{"
           "float y=step(0.,sin(atan(v.x,v.z)*60.));"
           "x=vec3(mix(1.,.1,y));"
           "i=mix(.9,.2,y);"
           "z=.1;"
         "}"
       "else"
         " if(a==4)"
           "x=vec3(.56,.57,.58),i=.2+.6*pow(n(v.xz*4.+40.),4.),z=.8;"
         "else"
           " if(a==5)"
             "x=vec3(1.,0.,0.),i=.2,z=.8;"
           "else"
             "{"
               "for(int y=0;y<LN;++y)"
                 "if(a==100+y)"
                   "m=l[y];"
             "}"
 "}"
 "float d(float v,float a)"
 "{"
   "a*=a;"
   "a*=a;"
   "float x=v*v*(a-1.)+1.;"
   "x=f*x*x;"
   "return a/x;"
 "}"
 "float e(float v,float f)"
 "{"
   "return f+=1.,f*=f/8.,v/(v*(1.-f)+f);"
 "}"
 "vec3 d(vec3 v,vec3 f,float x)"
 "{"
   "float a=0.,i=1000.;"
   "int z;"
   "for(z=0;z<128;++z)"
     "{"
       "vec3 m=v+f*a;"
       "float y=h(m);"
       "a+=y;"
       "i=min(i,y);"
       "if(y<.002*a||a>x)"
         "break;"
     "}"
   "return vec3(a,i,float(z));"
 "}"
 "vec3 e(vec3 a,vec3 x,vec3 m,vec3 i,float z,float y)"
 "{"
   "vec3 r=vec3(0.);"
   "for(int s=0;s<LN;++s)"
     "{"
       "vec3 o=c[s]-a;"
       "float n=dot(o,o),L=sqrt(n);"
       "o=normalize(o);"
       "vec3 h=d(a+.02*o,o,L);"
       "if(h.x+.2<L)"
         "continue;"
       "vec3 p=normalize(x+o),w=mix(vec3(.04),i,z);"
       "float u=max(dot(p,x),0.),b=max(dot(m,x),0.),g=max(dot(m,o),0.),N=max(dot(m,p),0.);"
       "vec3 F=w+(1.-w)*pow(1.-u,5.);"
       "float q=e(b,y)*e(g,y);"
       "vec3 k=d(N,y)*q*F/(4.*b*g+.001);"
       "r+=30.*(.7+.3*t(v*20.+float(s)))*((vec3(1.)-F)*(1.-z)*i/f+k)*g*l[s]/n;"
     "}"
   "return r;"
 "}"
 "mat3 h(vec3 v,vec3 f,vec3 a)"
 "{"
   "vec3 x=normalize(v-f),z=normalize(cross(a,x));"
   "a=cross(x,z);"
   "return mat3(z,a,x);"
 "}"
 "void main()"
 "{"
   "vec2 f=gl_FragCoord.xy/V.xy*2.-1.;"
   "f.x*=V.x/V.y;"
   "c[0]=vec3(11.,6.,11.);"
   "c[1]=vec3(11.,6.,-11.);"
   "c[2]=vec3(-11.,6.,-11.);"
   "c[3]=vec3(-11.,6.,11.);"
   "c[4]=vec3(0.);"
   "l[0]=vec3(.7,.35,.45);"
   "l[1]=vec3(.7,.35,.15);"
   "l[2]=vec3(.3,.35,.75);"
   "l[3]=vec3(.7,.35,.15);"
   "l[4]=vec3(D.x);"
   "vec3 a=C+.1*p(v*3.);"
   "mat3 x=h(a,A,m.xzx);"
   "vec3 z=x*normalize(vec3(f,-D.y)),i=m.xxx;"
   "const float y=40.;"
   "vec3 o=d(a,z,y),t=a+o.x*z,s,n,N;"
   "float L,w;"
   "d(t,N,n,s,w,L);"
   "i=n+e(t,-z,N,s,L,w);"
   "gl_FragColor=vec4(i,o.x);"
 "}";

#endif // RAYMARCH_H_
