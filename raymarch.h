/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef RAYMARCH_H_
# define RAYMARCH_H_

const char *raymarch_glsl =
 "uniform vec3 V,C,A;"
 "float v=V.z;"
 "const vec3 m=vec3(0.,.001,1.);"
 "const float f=3.14159;"
 "float x(float v)"
 "{"
   "return fract(sin(v)*43758.5);"
 "}"
 "float s(vec2 v)"
 "{"
   "return fract(sin(17.*x(v.x)+54.*x(v.y)));"
 "}"
 "float n(vec2 v)"
 "{"
   "vec2 a=floor(v);"
   "v-=a;"
   "return mix(mix(s(a),s(a+m.zx),v.x),mix(s(a+m.xz),s(a+m.zz),v.x),v.y);"
 "}"
 "float t(float v)"
 "{"
   "float a=floor(v);"
   "v-=a;"
   "return mix(x(a),x(a+1.),v);"
 "}"
 "vec3 r(float v)"
 "{"
   "return vec3(t(v),t(v+13.),t(v+29.));"
 "}"
 "float n(vec3 v,vec3 x)"
 "{"
   "return v=abs(v)-x,max(v.x,max(v.y,v.z));"
 "}"
 "mat3 p(float v)"
 "{"
   "float f=sin(v),a=cos(v);"
   "return mat3(a,0.,f,0.,1.,0,-f,0.,a);"
 "}"
 "float p(vec3 v,float x)"
 "{"
   "return length(v)-x;"
 "}"
 "vec3 r(vec3 v,vec3 f)"
 "{"
   "return mod(v,f)-f*.5;"
 "}"
 "float n(vec3 v,float f,float m,float x)"
 "{"
   "float a=length(v);"
   "return max(abs(v.y)-x,max(a-m,f-a));"
 "}"
 "float e(vec2 v)"
 "{"
   "return max(v.x,v.y);"
 "}"
 "float i(vec3 f)"
 "{"
   "const float a=2.8;"
   "const int x=5;"
   "vec3 m=vec3(1.1,.9,1.9);"
   "for(int i=0;i<x;++i)"
     "{"
       "f=f*p(.1+v*.3);"
       "f=abs(f);"
       "f.xy+=step(f.x,f.y)*(f.yx-f.xy);"
       "f.xz+=step(f.x,f.z)*(f.zx-f.xz);"
       "f.yz+=step(f.y,f.z)*(f.zy-f.yz);"
       "f=f*p(.7);"
       "f.xy=f.xy*a-(a-1.)*m.xy;"
       "f.z=a*f.z;"
       "if(f.z>.5*m.z*(a-1.))"
         "f.z-=m.z*(a-1.);"
     "}"
   "return n(f,vec3(1.))*pow(a,-float(x));"
 "}"
 "int a=0;"
 "void e(inout float v,float f,int m)"
 "{"
   "if(f<v)"
     "v=f,a=m;"
 "}"
 "float d(vec3 v)"
 "{"
   "float f=e(abs(v.xy)-vec2(2.,.1));"
   "f=f+max(0.,.2*n(r(v,vec3(.15)),vec3(.01)));"
   "v.x=abs(v.x)+.02;"
   "float a=e(abs(v.xy-vec2(2.,1.))-vec2(.02)),x=max(abs(mod(v.z,.4)-.2)-.02,max(abs(v.y-.5)-.5,abs(v.x-2.)-.02));"
   "return min(f,min(a,x));"
 "}"
 "float o(vec3 v)"
 "{"
   "return n(v-vec3(33.,1.6,0.),vec3(20.,1.5,1.96));"
 "}\n"
 "#define LN 5\n"
 "vec3 c[LN],l[LN];"
 "float h(vec3 f)"
 "{"
   "float a=100000.;"
   "for(int m=0;m<LN;++m)"
     "e(a,length(f-c[m])-.1,m+100);"
   "float m=length(f.xz),x=atan(f.x,f.z),t=length(f),z=-min(o(vec3(abs(f.x),f.yz)),o(vec3(abs(f.z),f.yx))),y=max(-p(f,19.),n(r(f,vec3(2.)),vec3(.8))),s=-p(f,20.);"
   "e(a,s,1);"
   "e(a,y,2);"
   "a=max(z,a);"
   "float l=p(f,9.);"
   "l=max(l,abs(abs(f.y)-3.)-.5);"
   "l=min(l,n(r(f,vec3(11.8)),vec3(.1,100.,.1)));"
   "l=max(l,-p(f,8.9));"
   "float h=d(vec3(m-13.,f.y,x*10.));"
   "h=min(h,max(15.-m,min(d(f.zyx),d(f))));"
   "h=max(h,z);"
   "e(a,l,3);"
   "e(a,h,4);"
   "if(v>44.)"
     "{"
       "if(t<8.)"
         "{"
           "float w=mix(.001,4.,smoothstep(44.,54.,v));"
           "e(a,i(f/w)*w,5);"
         "}"
       "else"
         " a=min(a,t+2.);"
     "}"
   "return a;"
 "}"
 "vec3 w(vec3 v)"
 "{"
   "float f=h(v);"
   "return normalize(vec3(h(v+m.yxx)-f,h(v+m.xyx)-f,h(v+m.xxy)-f));"
 "}"
 "void d(vec3 f,out vec3 m,out vec3 x,out vec3 i,out float h,out float z)"
 "{"
   "m=w(f);"
   "x=vec3(0.,1.,1.);"
   "i=vec3(0.);"
   "h=0.;"
   "z=.99;"
   "if(a==1)"
     "x=vec3(0.),i=vec3(1.),h=.5;"
   "else"
     " if(a==2)"
       "{"
         "float y=sin(v+dot(normalize(vec3(1.)),floor(f/2.)));"
         "i=max(0.,y)*vec3(1.);"
         "x=vec3(0.);"
         "h=.2;"
       "}"
     "else"
       " if(a==3)"
         "x=vec3(0.),i=vec3(1.),h=.8;"
       "else"
         " if(a==4)"
           "x=vec3(0.),i=vec3(.56,.57,.58),z=.8,h=.2+.6*pow(n(f.xz*4.+40.),4.);"
         "else"
           " if(a==5)"
             "x=vec3(0.),i=vec3(1.),h=.9,z=0.;"
           "else"
             "{"
               "for(int y=0;y<LN;++y)"
                 "if(a==100+y)"
                   "x=l[y],i=vec3(0.),h=0.,z=0.;"
             "}"
 "}"
 "float d(float v,float a)"
 "{"
   "a*=a;"
   "a*=a;"
   "float m=v*v*(a-1.)+1.;"
   "m=f*m*m;"
   "return a/m;"
 "}"
 "float e(float v,float f)"
 "{"
   "return f+=1.,f*=f/8.,v/(v*(1.-f)+f);"
 "}"
 "vec3 d(vec3 v,vec3 f,float x)"
 "{"
   "float a=0.,i=1000.;"
   "int m;"
   "for(m=0;m<128;++m)"
     "{"
       "vec3 z=v+f*a;"
       "float y=h(z);"
       "a+=y;"
       "i=min(i,y);"
       "if(y<.002*a||a>x)"
         "break;"
     "}"
   "return vec3(a,i,float(m));"
 "}"
 "vec3 e(vec3 v,vec3 a,vec3 m,vec3 x,float y,float z)"
 "{"
   "vec3 i=vec3(0.);"
   "for(int h=0;h<LN;++h)"
     "{"
       "vec3 t=c[h]-v;"
       "float s=dot(t,t),o=sqrt(s);"
       "t=normalize(t);"
       "vec3 n=d(v+.02*t,t,o);"
       "if(n.x+.2<o)"
         "continue;"
       "vec3 w=normalize(a+t),r=mix(vec3(.04),x,y);"
       "float p=max(dot(w,a),0.),u=max(dot(m,a),0.),b=max(dot(m,t),0.),g=max(dot(m,w),0.);"
       "vec3 L=r+(1.-r)*pow(1.-p,5.);"
       "float N=e(u,z)*e(b,z);"
       "vec3 F=d(g,z)*N*L/(4.*u*b+.001);"
       "i+=((vec3(1.)-L)*(1.-y)*x/f+F)*b*l[h]/s;"
     "}"
   "return i;"
 "}"
 "mat3 h(vec3 v,vec3 f,vec3 a)"
 "{"
   "vec3 m=normalize(v-f),x=normalize(cross(a,m));"
   "a=cross(m,x);"
   "return mat3(x,a,m);"
 "}"
 "void main()"
 "{"
   "vec2 f=gl_FragCoord.xy/V.xy*2.-1.;"
   "f.x*=V.x/V.y;"
   "float a=11.;"
   "c[0]=vec3(a,6.,a);"
   "c[1]=vec3(a,6.,-a);"
   "c[2]=vec3(-a,6.,-a);"
   "c[3]=vec3(-a,6.,a);"
   "c[4]=vec3(0.);"
   "l[0]=30.*vec3(.7,.35,.45)*mix(1.,t(v*20.),.3);"
   "l[1]=30.*vec3(.7,.35,.15)*mix(1.,t(v*20.+10.),.3);"
   "l[2]=30.*vec3(.3,.35,.75)*mix(1.,t(v*20.+20.),.3);"
   "l[3]=30.*vec3(.7,.35,.15)*mix(1.,t(v*20.+30.),.3);"
   "l[4]=smoothstep(44.,50.,v)*50.*vec3(1.)*mix(1.,t(v*20.+30.),.3);"
   "vec3 x=C+.1*r(v*3.);"
   "mat3 i=h(x,A,m.xzx);"
   "vec3 z=i*normalize(vec3(f,-1.44)),y=m.xxx;"
   "const float o=40.;"
   "vec3 s=d(x,z,o),w=x+s.x*z,u,n,N;"
   "float p,b;"
   "d(w,N,n,u,b,p);"
   "y=n+e(w,-z,N,u,p,b);"
   "gl_FragColor=vec4(y,s.x);"
 "}";

#endif // RAYMARCH_H_
