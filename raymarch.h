/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef RAYMARCH_H_
# define RAYMARCH_H_

const char *raymarch_glsl =
 "uniform vec3 V,C,A,D;"
 "float v=V.z;"
 "const vec3 m=vec3(0.,.001,1.);"
 "const float f=3.14159;"
 "float x(float v)"
 "{"
   "return fract(sin(v)*43758.5);"
 "}"
 "float s(vec2 v)"
 "{"
   "return fract(sin(17.*x(v.x)+54.*x(v.y)));"
 "}"
 "float n(vec2 v)"
 "{"
   "vec2 i=floor(v);"
   "v-=i;"
   "return mix(mix(s(i),s(i+m.zx),v.x),mix(s(i+m.xz),s(i+m.zz),v.x),v.y);"
 "}"
 "float a(float v)"
 "{"
   "float i=floor(v);"
   "v-=i;"
   "return mix(x(i),x(i+1.),v);"
 "}"
 "vec3 t(float v)"
 "{"
   "return vec3(a(v),a(v+13.),a(v+29.));"
 "}"
 "float a(vec3 v,vec3 x)"
 "{"
   "return v=abs(v)-x,max(v.x,max(v.y,v.z));"
 "}"
 "mat3 p(float v)"
 "{"
   "float f=sin(v),i=cos(v);"
   "return mat3(i,0.,f,0.,1.,0,-f,0.,i);"
 "}"
 "float n(vec3 v,float x)"
 "{"
   "return length(v)-x;"
 "}"
 "vec3 p(vec3 v,vec3 f)"
 "{"
   "return mod(v,f)-f*.5;"
 "}"
 "float a(vec3 v,float f,float x,float z)"
 "{"
   "float i=length(v);"
   "return max(abs(v.y)-z,max(i-x,f-i));"
 "}"
 "float r(vec2 v)"
 "{"
   "return max(v.x,v.y);"
 "}"
 "float e(vec3 f)"
 "{"
   "const float i=2.8;"
   "const int x=5;"
   "vec3 m=vec3(1.1,.9,1.9);"
   "for(int z=0;z<x;++z)"
     "{"
       "f=f*p(.1+v*.3);"
       "f=abs(f);"
       "f.xy+=step(f.x,f.y)*(f.yx-f.xy);"
       "f.xz+=step(f.x,f.z)*(f.zx-f.xz);"
       "f.yz+=step(f.y,f.z)*(f.zy-f.yz);"
       "f=f*p(.7);"
       "f.xy=f.xy*i-(i-1.)*m.xy;"
       "f.z=i*f.z;"
       "if(f.z>.5*m.z*(i-1.))"
         "f.z-=m.z*(i-1.);"
     "}"
   "return a(f,vec3(1.))*pow(i,-float(x));"
 "}"
 "int i=0;"
 "void a(inout float v,float f,int m)"
 "{"
   "if(f<v)"
     "v=f,i=m;"
 "}"
 "float d(vec3 v)"
 "{"
   "float f=r(abs(v.xy)-vec2(2.,.1));"
   "f=f+max(0.,.2*a(p(v,vec3(.15)),vec3(.01)));"
   "v.x=abs(v.x)+.02;"
   "float i=r(abs(v.xy-vec2(2.,1.))-vec2(.02)),x=max(abs(mod(v.z,.4)-.2)-.02,max(abs(v.y-.5)-.5,abs(v.x-2.)-.02));"
   "return min(f,min(i,x));"
 "}"
 "float o(vec3 v)"
 "{"
   "return a(v-vec3(33.,1.6,0.),vec3(20.,1.5,1.96));"
 "}\n"
 "#define LN 5\n"
 "vec3 c[LN],l[LN];"
 "float h(vec3 v)"
 "{"
   "float f=100000.;"
   "for(int i=0;i<LN;++i)"
     "a(f,length(v-c[i])-.1,i+100);"
   "float i=length(v.xz),m=atan(v.x,v.z),x=length(v),z=-min(o(vec3(abs(v.x),v.yz)),o(vec3(abs(v.z),v.yx))),s=max(-n(v,19.),a(p(v,vec3(2.)),vec3(.8))),y=-n(v,20.);"
   "a(f,y,1);"
   "a(f,s,2);"
   "f=max(z,f);"
   "float r=n(v,9.);"
   "r=max(r,abs(abs(v.y)-3.)-.5);"
   "r=min(r,a(p(v,vec3(11.8)),vec3(.1,100.,.1)));"
   "r=max(r,-n(v,8.9));"
   "float l=d(vec3(i-13.,v.y,m*10.));"
   "l=min(l,max(15.-i,min(d(v.zyx),d(v))));"
   "l=max(l,z);"
   "a(f,r,3);"
   "a(f,l,4);"
   "if(x<8.)"
     "a(f,e(v/D.x)*D.x,5);"
   "else"
     " f=min(f,x+2.);"
   "return f;"
 "}"
 "vec3 w(vec3 v)"
 "{"
   "float f=h(v);"
   "return normalize(vec3(h(v+m.yxx)-f,h(v+m.xyx)-f,h(v+m.xxy)-f));"
 "}"
 "void a(vec3 v,out vec3 f,out vec3 m,out vec3 r,out float x,out float z)"
 "{"
   "f=w(v);"
   "r=m=vec3(0.);"
   "x=z=0.;"
   "if(i==1)"
     "r=vec3(.5),x=.4,z=.99;"
   "else"
     " if(i==2)"
       "{"
         "float s=a(p(v,vec3(2.)),vec3(.6));"
         "r=vec3(.56,.57,.58);"
         "x=mix(.15,.5,step(s,0.));"
         "z=.8;"
       "}"
     "else"
       " if(i==3)"
         "{"
           "float y=step(0.,sin(atan(v.x,v.z)*60.));"
           "r=vec3(mix(1.,.1,y));"
           "x=mix(.9,.2,y);"
           "z=.1;"
         "}"
       "else"
         " if(i==4)"
           "r=vec3(.56,.57,.58),x=.2+.6*pow(n(v.xz*4.+40.),4.),z=.8;"
         "else"
           " if(i==5)"
             "r=vec3(1.,0.,0.),x=.2,z=.8;"
           "else"
             "{"
               "for(int y=0;y<LN;++y)"
                 "if(i==100+y)"
                   "m=l[y];"
             "}"
 "}"
 "float d(float v,float i)"
 "{"
   "i*=i;"
   "i*=i;"
   "float r=v*v*(i-1.)+1.;"
   "r=f*r*r;"
   "return i/r;"
 "}"
 "float e(float v,float f)"
 "{"
   "return f+=1.,f*=f/8.,v/(v*(1.-f)+f);"
 "}"
 "vec3 d(vec3 v,vec3 f,float x)"
 "{"
   "float i=0.,r=1000.;"
   "int z;"
   "for(z=0;z<128;++z)"
     "{"
       "vec3 m=v+f*i;"
       "float y=h(m);"
       "i+=y;"
       "r=min(r,y);"
       "if(y<.002*i||i>x)"
         "break;"
     "}"
   "return vec3(i,r,float(z));"
 "}"
 "vec3 d(vec3 v,vec3 i,vec3 x,vec3 m,float z,float y)"
 "{"
   "vec3 r=vec3(0.);"
   "for(int s=0;s<LN;++s)"
     "{"
       "vec3 a=c[s]-v;"
       "float n=dot(a,a),o=sqrt(n);"
       "a=normalize(a);"
       "vec3 h=d(v+.02*a,a,o);"
       "if(h.x+.2<o)"
         "continue;"
       "vec3 t=normalize(i+a),w=mix(vec3(.04),m,z);"
       "float p=max(dot(t,i),0.),u=max(dot(x,i),0.),b=max(dot(x,a),0.),g=max(dot(x,t),0.);"
       "vec3 L=w+(1.-w)*pow(1.-p,5.);"
       "float N=e(u,y)*e(b,y);"
       "vec3 F=d(g,y)*N*L/(4.*u*b+.001);"
       "r+=((vec3(1.)-L)*(1.-z)*m/f+F)*b*l[s]/n;"
     "}"
   "return r;"
 "}"
 "mat3 e(vec3 v,vec3 f,vec3 i)"
 "{"
   "vec3 x=normalize(v-f),z=normalize(cross(i,x));"
   "i=cross(x,z);"
   "return mat3(z,i,x);"
 "}"
 "void main()"
 "{"
   "vec2 f=gl_FragCoord.xy/V.xy*2.-1.;"
   "f.x*=V.x/V.y;"
   "float i=11.;"
   "c[0]=vec3(i,6.,i);"
   "c[1]=vec3(i,6.,-i);"
   "c[2]=vec3(-i,6.,-i);"
   "c[3]=vec3(-i,6.,i);"
   "c[4]=vec3(0.);"
   "l[0]=30.*vec3(.7,.35,.45)*mix(1.,a(v*20.),.3);"
   "l[1]=30.*vec3(.7,.35,.15)*mix(1.,a(v*20.+10.),.3);"
   "l[2]=30.*vec3(.3,.35,.75)*mix(1.,a(v*20.+20.),.3);"
   "l[3]=30.*vec3(.7,.35,.15)*mix(1.,a(v*20.+30.),.3);"
   "l[4]=50.*vec3(D.x)*mix(1.,a(v*20.+30.),.3);"
   "vec3 x=C+.1*t(v*3.);"
   "mat3 r=e(x,A,m.xzx);"
   "vec3 z=r*normalize(vec3(f,-D.y)),y=m.xxx;"
   "const float s=40.;"
   "vec3 o=d(x,z,s),h=x+o.x*z,u,n,N;"
   "float p,w;"
   "a(h,N,n,u,w,p);"
   "y=n+d(h,-z,N,u,p,w);"
   "gl_FragColor=vec4(y,o.x);"
 "}";

#endif // RAYMARCH_H_
