/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef RAYMARCH_H_
# define RAYMARCH_H_

const char *raymarch_glsl =
 "uniform float T;"
 "uniform vec2 V;"
 "const vec3 v=vec3(0.,.001,1.);"
 "const float m=3.14159;"
 "float f(float v)"
 "{"
   "return fract(sin(v)*43758.5);"
 "}"
 "float x(vec2 v)"
 "{"
   "return fract(sin(17.*f(v.x)+54.*f(v.y)));"
 "}"
 "float s(vec2 f)"
 "{"
   "vec2 m=floor(f);"
   "f-=m;"
   "return mix(mix(x(m),x(m+v.zx),f.x),mix(x(m+v.xz),x(m+v.zz),f.x),f.y);"
 "}"
 "float n(float v)"
 "{"
   "float m=floor(v);"
   "v-=m;"
   "return mix(f(m),f(m+1.),v);"
 "}"
 "float f(vec3 v,vec3 x)"
 "{"
   "return v=abs(v)-x,max(v.x,max(v.y,v.z));"
 "}"
 "mat3 t(float v)"
 "{"
   "float f=sin(v),a=cos(v);"
   "return mat3(a,0.,f,0.,1.,0,-f,0.,a);"
 "}"
 "float n(vec3 v,float m)"
 "{"
   "return length(v)-m;"
 "}"
 "vec3 s(vec3 v,vec3 f)"
 "{"
   "return mod(v,f)-f*.5;"
 "}"
 "float f(vec3 v,float f,float m,float x)"
 "{"
   "float a=length(v);"
   "return max(abs(v.y)-x,max(a-m,f-a));"
 "}"
 "float r(vec2 v)"
 "{"
   "return max(v.x,v.y);"
 "}"
 "float i(vec3 v)"
 "{"
   "const float m=2.8;"
   "const int a=5;"
   "vec3 s=vec3(1.1,.9,1.9);"
   "for(int x=0;x<a;++x)"
     "{"
       "v=v*t(.1+T*.3);"
       "v=abs(v);"
       "v.xy+=step(v.x,v.y)*(v.yx-v.xy);"
       "v.xz+=step(v.x,v.z)*(v.zx-v.xz);"
       "v.yz+=step(v.y,v.z)*(v.zy-v.yz);"
       "v=v*t(.7);"
       "v.xy=v.xy*m-(m-1.)*s.xy;"
       "v.z=m*v.z;"
       "if(v.z>.5*s.z*(m-1.))"
         "v.z-=s.z*(m-1.);"
     "}"
   "return f(v,vec3(1.))*pow(m,-float(a));"
 "}"
 "int a=0;"
 "void f(inout float v,float m,int f)"
 "{"
   "if(m<v)"
     "v=m,a=f;"
 "}"
 "float e(vec3 v)"
 "{"
   "float m=r(abs(v.xy)-vec2(2.,.1));"
   "m=m+max(0.,.2*f(s(v,vec3(.15)),vec3(.01)));"
   "v.x=abs(v.x)+.02;"
   "float a=r(abs(v.xy-vec2(2.,1.))-vec2(.02)),x=max(abs(mod(v.z,.4)-.2)-.02,max(abs(v.y-.5)-.5,abs(v.x-2.)-.02));"
   "return min(m,min(a,x));"
 "}"
 "float d(vec3 v)"
 "{"
   "return f(v-vec3(33.,1.6,0.),vec3(20.,1.5,1.96));"
 "}\n"
 "#define LN 5\n"
 "vec3 c[LN],o[LN];"
 "float l(vec3 v)"
 "{"
   "float m=100000.;"
   "for(int x=0;x<LN;++x)"
     "f(m,length(v-c[x])-.1,x+100);"
   "float a=length(v.xz),x=atan(v.x,v.z),o=length(v),z=-min(d(vec3(abs(v.x),v.yz)),d(vec3(abs(v.z),v.yx))),y=max(-n(v,19.),f(s(v,vec3(2.)),vec3(.8))),l=-n(v,20.);"
   "f(m,l,1);"
   "f(m,y,2);"
   "m=max(z,m);"
   "float r=n(v,9.);"
   "r=max(r,abs(abs(v.y)-3.)-.5);"
   "r=min(r,f(s(v,vec3(11.8)),vec3(.1,100.,.1)));"
   "r=max(r,-n(v,8.9));"
   "float t=e(vec3(a-13.,v.y,x*10.));"
   "t=min(t,max(15.-a,min(e(v.zyx),e(v))));"
   "t=max(t,z);"
   "f(m,r,3);"
   "f(m,t,4);"
   "if(T>44.)"
     "{"
       "if(o<8.)"
         "{"
           "float p=mix(.001,4.,smoothstep(44.,54.,T));"
           "f(m,i(v/p)*p,5);"
         "}"
       "else"
         " m=min(m,o+2.);"
     "}"
   "return m;"
 "}"
 "vec3 p(vec3 m)"
 "{"
   "float x=l(m);"
   "return normalize(vec3(l(m+v.yxx)-x,l(m+v.xyx)-x,l(m+v.xxy)-x));"
 "}"
 "void d(vec3 v,out vec3 m,out vec3 f,out vec3 x,out float r,out float i)"
 "{"
   "m=p(v);"
   "f=vec3(0.,1.,1.);"
   "x=vec3(0.);"
   "r=0.;"
   "i=.99;"
   "if(a==1)"
     "f=vec3(0.),x=vec3(1.),r=.5;"
   "else"
     " if(a==2)"
       "{"
         "float z=sin(T+dot(normalize(vec3(1.)),floor(v/2.)));"
         "x=max(0.,z)*vec3(1.);"
         "f=vec3(0.);"
         "r=.2;"
       "}"
     "else"
       " if(a==3)"
         "f=vec3(0.),x=vec3(1.),r=.8;"
       "else"
         " if(a==4)"
           "f=vec3(0.),x=vec3(.56,.57,.58),i=.8,r=.2+.6*pow(s(v.xz*4.+40.),4.);"
         "else"
           " if(a==5)"
             "f=vec3(0.),x=vec3(1.),r=.9,i=0.;"
           "else"
             "{"
               "for(int z=0;z<LN;++z)"
                 "if(a==100+z)"
                   "f=o[z],x=vec3(0.),r=0.,i=0.;"
             "}"
 "}"
 "float d(float v,float f)"
 "{"
   "f*=f;"
   "f*=f;"
   "float r=v*v*(f-1.)+1.;"
   "r=m*r*r;"
   "return f/r;"
 "}"
 "float e(float v,float m)"
 "{"
   "return m+=1.,m*=m/8.,v/(v*(1.-m)+m);"
 "}"
 "vec3 d(vec3 v,vec3 m,float x)"
 "{"
   "float f=0.,r=1000.;"
   "int a;"
   "for(a=0;a<128;++a)"
     "{"
       "vec3 z=v+m*f;"
       "float i=l(z);"
       "f+=i;"
       "r=min(r,i);"
       "if(i<.002*f||f>x)"
         "break;"
     "}"
   "return vec3(f,r,float(a));"
 "}"
 "vec3 e(vec3 v,vec3 f,vec3 a,vec3 x,float z,float i)"
 "{"
   "vec3 r=vec3(0.);"
   "for(int y=0;y<LN;++y)"
     "{"
       "vec3 n=c[y]-v;"
       "float t=dot(n,n),l=sqrt(t);"
       "n=normalize(n);"
       "vec3 s=d(v+.02*n,n,l);"
       "if(s.x+.2<l)"
         "continue;"
       "vec3 p=normalize(f+n),g=mix(vec3(.04),x,z);"
       "float L=max(dot(p,f),0.),u=max(dot(a,f),0.),b=max(dot(a,n),0.),h=max(dot(a,p),0.);"
       "vec3 N=g+(1.-g)*pow(1.-L,5.);"
       "float w=e(u,i)*e(b,i);"
       "vec3 F=d(h,i)*w*N/(4.*u*b+.001);"
       "r+=((vec3(1.)-N)*(1.-z)*x/m+F)*b*o[y]/t;"
     "}"
   "return r;"
 "}"
 "mat3 e(vec3 v,vec3 m,vec3 f)"
 "{"
   "vec3 x=normalize(v-m),a=normalize(cross(f,x));"
   "f=cross(x,a);"
   "return mat3(a,f,x);"
 "}"
 "void main()"
 "{"
   "vec2 m=gl_FragCoord.xy/V*2.-1.;"
   "m.x*=V.x/V.y;"
   "float f=11.;"
   "c[0]=vec3(f,6.,f);"
   "c[1]=vec3(f,6.,-f);"
   "c[2]=vec3(-f,6.,-f);"
   "c[3]=vec3(-f,6.,f);"
   "c[4]=vec3(0.);"
   "o[0]=30.*vec3(.7,.35,.45)*mix(1.,n(T*20.),.3);"
   "o[1]=30.*vec3(.7,.35,.15)*mix(1.,n(T*20.+10.),.3);"
   "o[2]=30.*vec3(.3,.35,.75)*mix(1.,n(T*20.+20.),.3);"
   "o[3]=30.*vec3(.7,.35,.15)*mix(1.,n(T*20.+30.),.3);"
   "o[4]=smoothstep(44.,50.,T)*50.*vec3(1.)*mix(1.,n(T*20.+30.),.3);"
   "vec3 x=normalize(vec3(m,-1.44)),a,r=vec3(0.);"
   "if(T<23.)"
     "a=vec3(mix(40.,11.,T/23.),2.,0.);"
   "else"
     " if(T<34.)"
       "{"
         "float i=T-34.;"
         "a=vec3(cos(i*.1)*13.,2.,sin(i*.1)*14.);"
         "r=vec3(20.,0.,20.);"
       "}"
     "else"
       " if(T<62.)"
         "a=vec3(cos(T*.1)*13.,2.,sin(T*.1)*14.);"
       "else"
         "{"
           "float i=T*2./10.48,z=floor(i);"
           "a=13.*mix(vec3(n(z),n(z+4.),n(z+5.)),vec3(n(z+17.),n(z+41.),n(z+35.)),i-z);"
         "}"
   "float z=T*3.;"
   "a+=.1*vec3(n(z),n(z+1.),n(z+3.));"
   "mat3 i=e(a,r,v.xzx);"
   "a+=i*vec3(m*.01,0.);"
   "x=i*x;"
   "vec3 t=vec3(0.);"
   "const float y=40.;"
   "vec3 s=d(a,x,y),l=a+s.x*x,p,g,N;"
   "float L,u;"
   "d(l,N,g,p,u,L);"
   "t=g+e(l,-x,N,p,L,u);"
   "gl_FragColor=vec4(t,s.x);"
 "}";

#endif // RAYMARCH_H_
