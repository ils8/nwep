/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef RAYMARCH_H_
# define RAYMARCH_H_

const char *raymarch_glsl =
 "uniform vec3 V;"
 "float v=V.z;"
 "const vec3 f=vec3(0.,.001,1.);"
 "const float m=3.14159;"
 "float x(float v)"
 "{"
   "return fract(sin(v)*43758.5);"
 "}"
 "float s(vec2 v)"
 "{"
   "return fract(sin(17.*x(v.x)+54.*x(v.y)));"
 "}"
 "float n(vec2 v)"
 "{"
   "vec2 m=floor(v);"
   "v-=m;"
   "return mix(mix(s(m),s(m+f.zx),v.x),mix(s(m+f.xz),s(m+f.zz),v.x),v.y);"
 "}"
 "float i(float v)"
 "{"
   "float m=floor(v);"
   "v-=m;"
   "return mix(x(m),x(m+1.),v);"
 "}"
 "float i(vec3 v,vec3 x)"
 "{"
   "return v=abs(v)-x,max(v.x,max(v.y,v.z));"
 "}"
 "mat3 t(float v)"
 "{"
   "float f=sin(v),a=cos(v);"
   "return mat3(a,0.,f,0.,1.,0,-f,0.,a);"
 "}"
 "float n(vec3 v,float m)"
 "{"
   "return length(v)-m;"
 "}"
 "vec3 s(vec3 v,vec3 m)"
 "{"
   "return mod(v,m)-m*.5;"
 "}"
 "float i(vec3 v,float f,float m,float x)"
 "{"
   "float a=length(v);"
   "return max(abs(v.y)-x,max(a-m,f-a));"
 "}"
 "float r(vec2 v)"
 "{"
   "return max(v.x,v.y);"
 "}"
 "float e(vec3 f)"
 "{"
   "const float m=2.8;"
   "const int a=5;"
   "vec3 s=vec3(1.1,.9,1.9);"
   "for(int x=0;x<a;++x)"
     "{"
       "f=f*t(.1+v*.3);"
       "f=abs(f);"
       "f.xy+=step(f.x,f.y)*(f.yx-f.xy);"
       "f.xz+=step(f.x,f.z)*(f.zx-f.xz);"
       "f.yz+=step(f.y,f.z)*(f.zy-f.yz);"
       "f=f*t(.7);"
       "f.xy=f.xy*m-(m-1.)*s.xy;"
       "f.z=m*f.z;"
       "if(f.z>.5*s.z*(m-1.))"
         "f.z-=s.z*(m-1.);"
     "}"
   "return i(f,vec3(1.))*pow(m,-float(a));"
 "}"
 "int a=0;"
 "void e(inout float v,float m,int f)"
 "{"
   "if(m<v)"
     "v=m,a=f;"
 "}"
 "float d(vec3 v)"
 "{"
   "float f=r(abs(v.xy)-vec2(2.,.1));"
   "f=f+max(0.,.2*i(s(v,vec3(.15)),vec3(.01)));"
   "v.x=abs(v.x)+.02;"
   "float m=r(abs(v.xy-vec2(2.,1.))-vec2(.02)),a=max(abs(mod(v.z,.4)-.2)-.02,max(abs(v.y-.5)-.5,abs(v.x-2.)-.02));"
   "return min(f,min(m,a));"
 "}"
 "float o(vec3 v)"
 "{"
   "return i(v-vec3(33.,1.6,0.),vec3(20.,1.5,1.96));"
 "}\n"
 "#define LN 5\n"
 "vec3 c[LN],l[LN];"
 "float p(vec3 f)"
 "{"
   "float m=100000.;"
   "for(int x=0;x<LN;++x)"
     "e(m,length(f-c[x])-.1,x+100);"
   "float a=length(f.xz),x=atan(f.x,f.z),p=length(f),z=-min(o(vec3(abs(f.x),f.yz)),o(vec3(abs(f.z),f.yx))),y=max(-n(f,19.),i(s(f,vec3(2.)),vec3(.8))),l=-n(f,20.);"
   "e(m,l,1);"
   "e(m,y,2);"
   "m=max(z,m);"
   "float r=n(f,9.);"
   "r=max(r,abs(abs(f.y)-3.)-.5);"
   "r=min(r,i(s(f,vec3(11.8)),vec3(.1,100.,.1)));"
   "r=max(r,-n(f,8.9));"
   "float t=d(vec3(a-13.,f.y,x*10.));"
   "t=min(t,max(15.-a,min(d(f.zyx),d(f))));"
   "t=max(t,z);"
   "e(m,r,3);"
   "e(m,t,4);"
   "if(v>44.)"
     "{"
       "if(p<8.)"
         "{"
           "float h=mix(.001,4.,smoothstep(44.,54.,v));"
           "e(m,e(f/h)*h,5);"
         "}"
       "else"
         " m=min(m,p+2.);"
     "}"
   "return m;"
 "}"
 "vec3 h(vec3 v)"
 "{"
   "float m=p(v);"
   "return normalize(vec3(p(v+f.yxx)-m,p(v+f.xyx)-m,p(v+f.xxy)-m));"
 "}"
 "void d(vec3 f,out vec3 m,out vec3 r,out vec3 i,out float x,out float z)"
 "{"
   "m=h(f);"
   "r=vec3(0.,1.,1.);"
   "i=vec3(0.);"
   "x=0.;"
   "z=.99;"
   "if(a==1)"
     "r=vec3(0.),i=vec3(1.),x=.5;"
   "else"
     " if(a==2)"
       "{"
         "float y=sin(v+dot(normalize(vec3(1.)),floor(f/2.)));"
         "i=max(0.,y)*vec3(1.);"
         "r=vec3(0.);"
         "x=.2;"
       "}"
     "else"
       " if(a==3)"
         "r=vec3(0.),i=vec3(1.),x=.8;"
       "else"
         " if(a==4)"
           "r=vec3(0.),i=vec3(.56,.57,.58),z=.8,x=.2+.6*pow(n(f.xz*4.+40.),4.);"
         "else"
           " if(a==5)"
             "r=vec3(0.),i=vec3(1.),x=.9,z=0.;"
           "else"
             "{"
               "for(int y=0;y<LN;++y)"
                 "if(a==100+y)"
                   "r=l[y],i=vec3(0.),x=0.,z=0.;"
             "}"
 "}"
 "float d(float v,float f)"
 "{"
   "f*=f;"
   "f*=f;"
   "float r=v*v*(f-1.)+1.;"
   "r=m*r*r;"
   "return f/r;"
 "}"
 "float e(float v,float m)"
 "{"
   "return m+=1.,m*=m/8.,v/(v*(1.-m)+m);"
 "}"
 "vec3 d(vec3 m,vec3 v,float f)"
 "{"
   "float r=0.,i=1000.;"
   "int x;"
   "for(x=0;x<128;++x)"
     "{"
       "vec3 a=m+v*r;"
       "float z=p(a);"
       "r+=z;"
       "i=min(i,z);"
       "if(z<.002*r||r>f)"
         "break;"
     "}"
   "return vec3(r,i,float(x));"
 "}"
 "vec3 e(vec3 v,vec3 f,vec3 a,vec3 i,float x,float z)"
 "{"
   "vec3 r=vec3(0.);"
   "for(int y=0;y<LN;++y)"
     "{"
       "vec3 t=c[y]-v;"
       "float s=dot(t,t),o=sqrt(s);"
       "t=normalize(t);"
       "vec3 n=d(v+.02*t,t,o);"
       "if(n.x+.2<o)"
         "continue;"
       "vec3 p=normalize(f+t),h=mix(vec3(.04),i,x);"
       "float L=max(dot(p,f),0.),u=max(dot(a,f),0.),b=max(dot(a,t),0.),g=max(dot(a,p),0.);"
       "vec3 N=h+(1.-h)*pow(1.-L,5.);"
       "float w=e(u,z)*e(b,z);"
       "vec3 F=d(g,z)*w*N/(4.*u*b+.001);"
       "r+=((vec3(1.)-N)*(1.-x)*i/m+F)*b*l[y]/s;"
     "}"
   "return r;"
 "}"
 "mat3 h(vec3 v,vec3 m,vec3 f)"
 "{"
   "vec3 x=normalize(v-m),a=normalize(cross(f,x));"
   "f=cross(x,a);"
   "return mat3(a,f,x);"
 "}"
 "void main()"
 "{"
   "vec2 m=gl_FragCoord.xy/V.xy*2.-1.;"
   "m.x*=V.x/V.y;"
   "float x=11.;"
   "c[0]=vec3(x,6.,x);"
   "c[1]=vec3(x,6.,-x);"
   "c[2]=vec3(-x,6.,-x);"
   "c[3]=vec3(-x,6.,x);"
   "c[4]=vec3(0.);"
   "l[0]=30.*vec3(.7,.35,.45)*mix(1.,i(v*20.),.3);"
   "l[1]=30.*vec3(.7,.35,.15)*mix(1.,i(v*20.+10.),.3);"
   "l[2]=30.*vec3(.3,.35,.75)*mix(1.,i(v*20.+20.),.3);"
   "l[3]=30.*vec3(.7,.35,.15)*mix(1.,i(v*20.+30.),.3);"
   "l[4]=smoothstep(44.,50.,v)*50.*vec3(1.)*mix(1.,i(v*20.+30.),.3);"
   "vec3 r=normalize(vec3(m,-1.44)),a,z=vec3(0.);"
   "if(v<23.)"
     "a=vec3(mix(40.,11.,v/23.),2.,0.);"
   "else"
     " if(v<34.)"
       "{"
         "float t=v-34.;"
         "a=vec3(cos(t*.1)*13.,2.,sin(t*.1)*14.);"
         "z=vec3(20.,0.,20.);"
       "}"
     "else"
       " if(v<62.)"
         "a=vec3(cos(v*.1)*13.,2.,sin(v*.1)*14.);"
       "else"
         "{"
           "float y=v*2./10.48,t=floor(y);"
           "a=13.*mix(vec3(i(t),i(t+4.),i(t+5.)),vec3(i(t+17.),i(t+41.),i(t+35.)),y-t);"
         "}"
   "float t=v*3.;"
   "a+=.1*vec3(i(t),i(t+1.),i(t+3.));"
   "mat3 s=h(a,z,f.xzx);"
   "a+=s*vec3(m*.01,0.);"
   "r=s*r;"
   "vec3 y=vec3(0.);"
   "const float o=40.;"
   "vec3 p=d(a,r,o),n=a+p.x*r,u,b,N;"
   "float L,g;"
   "d(n,N,b,u,g,L);"
   "y=b+e(n,-r,N,u,L,g);"
   "gl_FragColor=vec4(y,p.x);"
 "}";

#endif // RAYMARCH_H_
