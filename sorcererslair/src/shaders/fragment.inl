static const char* fragment = \
"uniform int v;\n"
"float T=v*.0001;\n"
"const vec3 E = vec3(.0,1e-4,1.);\n"
"const float PI = 3.14159265359;\n"
"float hash(vec2 p){return fract(1e4*sin(17.*p.x+.1*p.y)*(.1+abs(sin(13.*p.y+p.x))));}\n"
"float hash(vec3 p){return hash(vec2(hash(p.xy), p.z));}\n"
"float noise(vec3 p){\n"
"vec3 P=floor(p);p=p-P;\n"
"p*=p*(3.-2.*p);\n"
"return mix(\n"
"mix(mix(hash(P), hash(P+E.zxx), p.x), mix(hash(P+E.xzx), hash(P+E.zzx), p.x), p.y),\n"
"mix(mix(hash(P+E.xxz), hash(P+E.zxz), p.x), mix(hash(P+E.xzz), hash(P+E.zzz), p.x), p.y), p.z);\n"
"}\n"
"float map(vec3 p){\n"
"vec3 offs = vec3(1., 1.75, .5);\n"
"const vec2 a = sin(vec2(0, 1.57079632) + 1.57/2.);\n"
"const mat2 m = mat2(a.y, -a.x, a);\n"
"vec2 a2 = sin(vec2(0, 1.57079632) + 1.57/4. + T);\n"
"mat2 m2 = mat2(a2.y, -a2.x, a2);\n"
"const float s = 6.;\n"
"float d = 1e5;\n"
"float amp = 1./s;\n"
"for(int i=0; i<4; i++){\n"
"p.xy = m*p.xy;\n"
"p.yz = m2*p.yz;\n"
"p = abs(p);\n"
"p.xz += step(p.x, p.z)*(p.zx - p.xz);\n"
"p.yz += step(p.y, p.z)*(p.zy - p.yz);\n"
"p = p*s + offs*(1. - s);\n"
"p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);\n"
"d = min(d, max(max(p.x, p.y), p.z)*amp);\n"
"d = min(d, (length(p)-6.*amp));\n"
"amp /= s;\n"
"}\n"
"return d - .0035;\n"
"}\n"
"float box(vec3 p, vec3 s) {\n"
"p = abs(p) - s;\n"
"return max(p.x, max(p.y, p.z));\n"
"}\n"
"mat3 RX(float a){\n"
"float s=sin(a),c=cos(a);\n"
"return mat3(1.,0.,0.,0.,c,-s,0.,s,c);\n"
"}\n"
"mat3 RY(float a){\n"
"float s=sin(a),c=cos(a);\n"
"return mat3(c,0.,s,0.,1.,0,-s,0.,c);\n"
"}\n"
"mat3 RZ(float a){\n"
"float s=sin(a),c=cos(a);\n"
"return mat3(c,s,0.,-s,c,0.,0.,0.,1.);\n"
"}\n"
"float F(vec3 p) {\n"
"p = RY(T) * p;\n"
"const float scale = 2., rscale = 1. / scale;\n"
"float w = 1e5;\n"
"vec2 a1 = sin(vec2(0., PI/2.) + 2. + T);\n"
"mat2 m1 = mat2(a1.y, -a1.x, a1);\n"
"vec2 a2 = sin(vec2(0., PI/2.) + .1  - T);\n"
"mat2 m2 = mat2(a2.y, -a2.x, a2);\n"
"float bs = .3;\n"
"float s = 1.;\n"
"const int N = 4;\n"
"for (int i = 0; i < N; ++i) {\n"
"p.xy += step(p.x, p.y)*(p.yx - p.xy);\n"
"p.xz += step(p.x, p.z)*(p.zx - p.xz);\n"
"p.yz += step(p.y, p.z)*(p.zy - p.yz);\n"
"p.yx = m2 * p.yx;\n"
"p.zy = m1 * p.zy;\n"
"vec2 ss = vec2(.5,2.) * s;\n"
"float d = min(min(\n"
"box(p, vec3(bs) * ss.yxx),\n"
"box(p, vec3(bs) * ss.xyx)),\n"
"box(p, vec3(bs) * ss.xxy));\n"
"d = max(-d, box(p, vec3(bs) * s));\n"
"w = min(w, d);\n"
"p.x -= .3;\n"
"p = p * scale;\n"
"s *= rscale;\n"
"}\n"
"return w - .002;\n"
"}\n"
"float F2(vec3 p) {\n"
"p = RY(T*.1) * p;\n"
"float S = 1.2;\n"
"const int N = 4;\n"
"mat3 M = RY(.3) * RZ(2.+.1*sin(T));\n"
"vec3 off = (vec3(-.4,-1.4,-.7));\n"
"p /= S;\n"
"for (int i = 0; i < N; ++i) {\n"
"p.xy += step(p.x, p.y)*(p.yx - p.xy);\n"
"p.xz += step(p.x, p.z)*(p.zx - p.xz);\n"
"p = abs(p);\n"
"p.yz += step(p.y, p.z)*(p.zy - p.yz);\n"
"p *= S;\n"
"p += off;\n"
"p = M * p;\n"
"}\n"
"return max(-box(p,vec3(.9,1e5,.9)*S), length(p) - S * 1.3) * pow(S, -float(N));\n"
"}\n"
"float F3(vec3 p) {\n"
"p = RY(T*.1) * p;\n"
"const float S = 3.;\n"
"const int N = 8;\n"
"vec3 C = vec3(1.,1.9,1.1);\n"
"for (int i = 0; i < N; ++i) {\n"
"p = p * RY(.1);\n"
"p = abs(p);\n"
"p.xy += step(p.x, p.y)*(p.yx - p.xy);\n"
"p.xz += step(p.x, p.z)*(p.zx - p.xz);\n"
"p.yz += step(p.y, p.z)*(p.zy - p.yz);\n"
"p = p * RZ(.1);\n"
"p.xy = mix(p.xy, C.xy, S);\n"
"p.z = S * p.z;\n"
"if (p.z > .5 * C.z * (S - 1.))\n"
"p.z -= C.z * (S - 1.);\n"
"}\n"
"return box(p, vec3(2.)) * pow(S, -float(N));\n"
"}\n"
"float F4(vec3 p) {\n"
"p = RY(T*.1) * p;\n"
"const float S = 2.8;\n"
"const int N = 5;\n"
"vec3 C = vec3(1.,.9,1.1);\n"
"for (int i = 0; i < N; ++i) {\n"
"p = p * RY(.1+T*.3);\n"
"p = abs(p);\n"
"p.xy += step(p.x, p.y)*(p.yx - p.xy);\n"
"p.xz += step(p.x, p.z)*(p.zx - p.xz);\n"
"p.yz += step(p.y, p.z)*(p.zy - p.yz);\n"
"p = p * RZ(.1);\n"
"p.xy = p.xy * S - (S - 1.) * C.xy;\n"
"p.z = S * p.z;\n"
"if (p.z > .5 * C.z * (S - 1.))\n"
"p.z -= C.z * (S - 1.);\n"
"}\n"
"return box(p, vec3(1.)) * pow(S, -float(N));\n"
"}\n"
"float ball(vec3 p, float r) { return length(p) - r; }\n"
"vec3 rep(vec3 p, vec3 r) { return mod(p,r) - r*.5; }\n"
"float ring(vec3 p, float r, float R, float t) {\n"
"float pr = length(p);\n"
"return max(abs(p.y)-t, max(pr - R, r - pr));\n"
"}\n"
"float vmax(vec2 p) { return max(p.x, p.y); }\n"
"float path(vec3 p) {\n"
"float flr = vmax(abs(p.xy) - vec2(2.,.1));\n"
"p.x = abs(p.x)+.02;\n"
"float rls = vmax(abs(p.xy-vec2(2.,1.)) - vec2(.02));\n"
"float rlst = max(abs(mod(p.z,.4)-.2)-.02, max(abs(p.y-.5)-.5, abs(p.x-2.)-.02));\n"
"return min(flr, min(rls, rlst));\n"
"}\n"
"float hole(vec3 p) {\n"
"return box(p-vec3(33.,1.6,0.), vec3(20.,1.5,1.96));\n"
"}\n"
"float room(vec3 p) {\n"
"float holes = -min(hole(vec3(abs(p.x), p.yz)), hole(vec3(abs(p.z), p.yx)));\n"
"float boxes = max(-ball(p,19.), box(rep(p, vec3(2.)), vec3(.8)));\n"
"float extwall = -ball(p,20.);\n"
"float wall = max(holes, min(extwall, boxes));\n"
"float rings = ball(p,9.);\n"
"rings = max(rings, abs(abs(p.y)-3.)-.5);\n"
"rings = min(rings, box(rep(p,vec3(11.8)), vec3(.1, 100., .1)));\n"
"rings = max(rings, -ball(p,8.9));\n"
"float paths = path(vec3(length(p.xz)-13., p.y, atan(p.x, p.z)*10.));\n"
"paths = min(paths, max(15.-length(p.xz), min(path(p.zyx), path(p))));\n"
"paths = max(paths, holes);\n"
"float scene = wall;\n"
"scene = min(scene, rings);\n"
"scene = min(scene, paths);\n"
"return scene;\n"
"}\n"
"float W(vec3 p) {\n"
"float kifs = F4(p/4.);\n"
"float room = room(p);\n"
"return min(kifs, room);\n"
"}\n"
"vec3 N(vec3 p) {\n"
"float w=W(p);\n"
"return normalize(vec3(W(p+E.yxx)-w,W(p+E.xyx)-w,W(p+E.xxy)-w));\n"
"}\n"
"void MT(vec3 p, out vec3 albedo, out float roughness) {\n"
"if (p.y < -.9) albedo = vec3(1.); else {\n"
"if (p.x < -.9) albedo = vec3(1.,0.,0.); else\n"
"if (p.x > .9) albedo = vec3(0.,0.,1.); else\n"
"albedo = vec3(0.,1.,0.);\n"
"}\n"
"roughness = 1.;\n"
"}\n"
"vec3 fresnelSchlick(float cosTheta, vec3 F0) {\n"
"return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n"
"}\n"
"float DistributionGGX(vec3 N, vec3 H, float roughness)\n"
"{\n"
"float a      = roughness*roughness;\n"
"float a2     = a*a;\n"
"float NdotH  = max(dot(N, H), 0.0);\n"
"float NdotH2 = NdotH*NdotH;\n"
"float nom   = a2;\n"
"float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n"
"denom = PI * denom * denom;\n"
"return nom / denom;\n"
"}\n"
"float GeometrySchlickGGX(float NdotV, float roughness)\n"
"{\n"
"float r = (roughness + 1.0);\n"
"float k = (r*r) / 8.0;\n"
"float nom   = NdotV;\n"
"float denom = NdotV * (1.0 - k) + k;\n"
"return nom / denom;\n"
"}\n"
"float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n"
"{\n"
"float NdotV = max(dot(N, V), 0.0);\n"
"float NdotL = max(dot(N, L), 0.0);\n"
"float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n"
"float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n"
"return ggx1 * ggx2;\n"
"}\n"
"#define LN 3\n"
"vec3 LP[3], LC[3];\n"
"vec3 pbf(vec3 p, vec3 V, vec3 N, float ao, vec3 albedo, float metallic, float roughness) {\n"
"vec3 Lo = vec3(0.0);\n"
"for(int i = 0; i < LN; ++i) {\n"
"vec3 L = normalize(LP[i] - p);\n"
"vec3 H = normalize(V + L);\n"
"float distance    = length(LP[i] - p);\n"
"float attenuation = 1.0 / (distance * distance);\n"
"vec3 radiance     = LC[i] * attenuation;\n"
"vec3 F0 = vec3(0.04);\n"
"F0      = mix(F0, albedo, metallic);\n"
"vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);\n"
"float NDF = DistributionGGX(N, H, roughness);\n"
"float G   = GeometrySmith(N, V, L, roughness);\n"
"vec3 nominator    = NDF * G * F;\n"
"float denominator = 4 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;\n"
"vec3 brdf         = nominator / denominator;\n"
"vec3 kS = F;\n"
"vec3 kD = vec3(1.0) - kS;\n"
"kD *= 1.0 - metallic;\n"
"float NdotL = max(dot(N, L), 0.0);\n"
"Lo += (kD * albedo / PI + brdf) * radiance * NdotL;\n"
"}\n"
"vec3 ambient = vec3(0.03) * albedo * ao;\n"
"return ambient + Lo;\n"
"}\n"
"const float ML = 40.;\n"
"vec3 trace(vec3 o, vec3 d) {\n"
"vec3 p,n;\n"
"float l = 0.;\n"
"for (int i = 0; i < 164; ++i) {\n"
"p = o+d*l;\n"
"float w = W(p);\n"
"l += w;\n"
"if (w < .001*l || l > ML) break;\n"
"}\n"
"if (l > ML) return vec3(.0);\n"
"vec3 albedo = vec3(1.);\n"
"n = N(p);\n"
"#if 1\n"
"vec3 c = pbf(p + n * .01, -d, n, .0, vec3(1.),\n"
"pow(noise(p*4.),4.),\n"
"pow(noise(p*4.+40.),4.));\n"
"#elif 0\n"
"p += n * .01;\n"
"d = -d;\n"
"vec3 c = vec3(.001);\n"
"for(int i = 0; i < LN; ++i) {\n"
"vec3 L = LP[i] - p;\n"
"float shadow = 1.;\n"
"#if 1\n"
"const int SS = 32;\n"
"for (int j = 0; j < SS; ++j) {\n"
"float w=W(p + L * float(j+1) / float(SS));\n"
"shadow = min(shadow, w);\n"
"}\n"
"shadow = pow(max(0.,shadow), .3);\n"
"#endif\n"
"float dL = max(0.,dot(n,normalize(L)));\n"
"c += albedo * shadow * dL * LC[i] / dot(L,L);\n"
"}\n"
"#else\n"
"vec3 c = vec3(.05) + .95 * max(0., dot(n,normalize(vec3(1.))));\n"
"#endif\n"
"return c;\n"
"}\n"
"void main() {\n"
"vec2 V=vec2(1280,720);\n"
"vec3 M=vec3(5.0,180.0,220.0*cos(T*0.2));\n"
"vec2 uv = gl_FragCoord.xy / V * 2. - 1.;\n"
"uv.x *= V.x / V.y;\n"
"LP[0] = vec3(5.*sin(T), 5., 5.*cos(T));\n"
"LP[1] = vec3(5.*sin(-T+3.), 5., 5.*cos(T+3.));\n"
"LP[2] = vec3(5.*sin(-T*.4+3.), 9.*sin(T*.7), 5.*cos(T*.5+3.));\n"
"LC[0] = vec3(10.);\n"
"LC[1] = vec3(9.,10.,5.);\n"
"LC[2] = vec3(14.,7.,3.);\n"
"mat3 ML = RY(M.x*2e-3) * RX(M.y*2e-3);\n"
"vec3 O = ML * vec3(0., 0., max(.1, M.z/10.));\n"
"vec3 D = ML * normalize(vec3(uv, -1.44));\n"
"vec3 color = trace(O, D);\n"
"color = color / (color + vec3(1.0));\n"
"color = pow(color, vec3(1.0/2.2));\n"
"gl_FragColor = vec4(color, 1.);\n"
"}\n";